---
networks:
  default:
    external: true
    name: proxy-tsnet

volumes:
  traefik-state:

services:
  # Tailscale sidecar for Traefik. This container is responsible for
  # connecting the Traefik container to the Tailscale network. It allows
  # traffic from my tailnet to reach the Traefik container.
  traefik-ts:
    image: tailscale/tailscale:latest
    container_name: traefik-ts
    hostname: traefik
    restart: unless-stopped
    environment:
      - TS_AUTHKEY=${TS_AUTH}
      - TS_EXTRA_ARGS=--advertise-tags=tag:container 
      - TS_ACCEPT_DNS=true
      - TS_STATE_DIR=/var/lib/tailscale
      - TS_USERSPACE=false
    volumes:
      - traefik-state:/var/lib/tailscale
      - /dev/net/tun:/dev/net/tun
    cap_add:
      - net_admin
      - sys_module

  # Traefik container for serving HTTP/(soon HTTPS) traffic. This container 
  # is configured as a reverse proxy for other services in the network. I have 
  # CNAME records for each service in my DNS server that point to the
  # Tailnet IP address of the sidecar container, and those requests are
  # handled by this service.  
  traefik-srv:
    image: traefik:v3.1
    container_name: traefik-srv
    network_mode: service:traefik-ts
    restart: unless-stopped
    depends_on:
      - traefik-ts
    configs:
      - source: traefik.toml
        target: /etc/traefik/traefik.toml
      - source: dynamic.toml
        target: /etc/traefik/dynamic.toml
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    healthcheck:
      test: ["CMD", "traefik", "healthcheck", "--ping"]
      interval: 10s
      timeout: 5s
      retries: 5

# This config is inlined because it's convenient and I deploy
# this stack to a remote docker host via a docker context. And doing
# it this way is easier than managing the config file on the remote host.
configs:
  traefik.toml:
    content: |
      [global]
        checkNewVersion = true
        sendAnonymousUsage = false
        [metrics]
          [metrics.prometheus]
            addEntryPointsLabels = true
      [entryPoints]
        [entryPoints.web]
          address = ":80"
          asDefault = true
          [entryPoints.web.forwardedHeaders]
            insecure = true
          [entryPoints.web.proxyProtocol]
            insecure = true
        [entryPoints.websecure]
          address = ":443"
          [entryPoints.websecure.forwardedHeaders]
            insecure = true
          [entryPoints.websecure.proxyProtocol]
            insecure = true
        [entryPoints.ssh]
          address = ":22"
        [entryPoints.traefik]
          address = ":8081"
      [log]
        format = "json"
      [accessLog]
        format = "json"
      [api]
        insecure = true
      [ping]
        entryPoint = "traefik"
      [providers.docker]
        endpoint = "unix:///var/run/docker.sock"
        defaultRule = "Host(`{{ .ContainerName }}.ecs.lan`)"
        exposedByDefault = false
      [providers.file]
        filename = "/etc/traefik/dynamic.toml"

  dynamic.toml:
    content: |
      [http]
      [http.routers]
        [http.routers.coder-rtr]
          entryPoints = ["web"]
          service = "coder-svc"
          rule = "Host(`coder.ecs.lan`)"

      [http.services]
        [http.services.coder-svc.loadBalancer]
          [[http.services.coder-svc.loadBalancer.servers]]
            url = "http://mbp:3001"
